
# Firestore Database Setup and Structure for TeamEase

This guide explains how to set up your Firestore database in the Firebase console and outlines the data structure that the TeamEase application is designed to work with.

## 1. Creating Firestore Database in Firebase Console

If you haven't already, you need to create a Firestore database instance for your Firebase project:

1.  **Go to your Firebase Project:** Open the [Firebase Console](https://console.firebase.google.com/) and select your project.
2.  **Navigate to Firestore Database:** In the left-hand navigation pane, under "Build", click on "Firestore Database".
3.  **Create Database:**
    *   Click the "Create database" button.
    *   **Choose a mode:**
        *   **Production mode:** Starts with secure rules (denying all access by default). This is recommended. You will need to add security rules later (see section 4).
        *   **Test mode:** Starts with open rules (allowing all reads/writes for 30 days). Useful for initial development but **must be secured before production.**
    *   **Choose a location:** Select the region where your data will be stored. This cannot be changed later. Choose a location close to your users.
    *   Click "Enable".

Your Firestore database is now ready.

## 2. Firestore Data Structure

The application uses the following collection and subcollection structure to support multi-tenancy (each team has its own environment) and roles (admin, player).

### Collection: `teams`

This is a top-level collection where each document represents a unique team.

*   **Document ID:** Auto-generated by Firestore (this ID is referred to as `teamId` in the application).
*   **Fields:**
    *   `name`: (String) The name of the team (e.g., "The Eagles").
    *   `ownerUid`: (String) The Firebase Auth UID of the user who created/owns the team. This user is typically the first admin.
    *   `createdAt`: (Timestamp) Server timestamp indicating when the team was created.

*   **Subcollection of `teams/{teamId}`: `matches`**
    *   Stores all matches for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `date`: (String) Match date in "yyyy-MM-dd" format.
        *   `time`: (String) Match time in "HH:mm" format (24-hour).
        *   `opponent`: (String) Name of the opponent team.
        *   `location`: (String, optional) Venue of the match.
        *   `attendance`: (Map) Stores player attendance.
            *   Keys: Player Firebase Auth UIDs (String).
            *   Values: (String) "present", "absent", "excused", or "unknown".
            *   Example: `{"playerUid1": "present", "playerUid2": "absent"}`
        *   `order`: (Number, optional) For drag-and-drop reordering of matches.

*   **Subcollection of `teams/{teamId}`: `trainings`**
    *   Stores all training sessions for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `date`: (String) Training date in "yyyy-MM-dd" format.
        *   `time`: (String) Training time in "HH:mm" format (24-hour).
        *   `location`: (String) Location of the training session.
        *   `description`: (String, optional) Additional details about the training.
        *   `attendance`: (Map) Stores player attendance (same structure as in `matches`).
        *   `order`: (Number, optional) For drag-and-drop reordering of training sessions.

### Collection: `users`

This is a top-level collection where each document represents a user profile.

*   **Document ID:** Should be the Firebase Auth UID of the user.
*   **Fields:**
    *   `uid`: (String) The Firebase Auth UID (can be the same as the document ID, useful for querying).
    *   `name`: (String) Full name of the user.
    *   `email`: (String) Email address of the user (should be stored in lowercase for consistency).
    *   `role`: (String) User's role within their team. Can be "admin" or "player".
    *   `teamId`: (String) The ID of the team (from the `teams` collection) that this user belongs to. This is crucial for multi-tenancy.
    *   `avatarUrl`: (String, optional) URL to the user's profile picture.
    *   `createdAt`: (Timestamp) Server timestamp indicating when the user profile was created.

## 3. Example Document Structure

**Example `teams` document (`/teams/uniqueTeamId123`):**
```json
{
  "name": "The Roaring Lions",
  "ownerUid": "firebaseUserUidAbc",
  "createdAt": "October 26, 2023 at 10:00:00 AM UTC+2" // Firestore Timestamp
}
```

**Example `matches` subcollection document (`/teams/uniqueTeamId123/matches/matchId456`):**
```json
{
  "date": "2023-11-05",
  "time": "15:00",
  "opponent": "The Sharks",
  "location": "Community Stadium",
  "attendance": {
    "playerUidXyz": "present",
    "playerUidPqr": "excused"
  },
  "order": 0
}
```

**Example `users` document (`/users/firebaseUserUidAbc`):**
```json
{
  "uid": "firebaseUserUidAbc",
  "name": "Jane Doe",
  "email": "jane.doe@example.com",
  "role": "admin",
  "teamId": "uniqueTeamId123",
  "avatarUrl": "https://picsum.photos/seed/jane.doe@example.com/80/80",
  "createdAt": "October 26, 2023 at 09:55:00 AM UTC+2" // Firestore Timestamp
}
```

## 4. Initial Data and Security Rules

*   **Initial Data:**
    *   When a new user signs up through the app, their user profile (`users` document) and a new team (`teams` document) are created automatically if they are the first user creating a team.
    *   Admins can add other players to their team via the app, which will create corresponding `users` documents.
    *   Matches and Trainings are added by team admins through the app.
    *   You generally do not need to add data manually to Firestore unless for testing or specific migration scenarios.

*   **Firestore Security Rules (VERY IMPORTANT):**
    *   The default security rules (especially in "Production mode") are very restrictive. You **must** configure Firestore Security Rules to allow your application to read and write data appropriately while protecting user and team data.
    *   Security rules are crucial for enforcing multi-tenancy (e.g., a user can only access data for their own team) and role-based access (e.g., only an admin can create matches).
    *   A conceptual example of security rules that align with this structure:
        ```firestore-rules
        rules_version = '2';
        service cloud.firestore {
          match /databases/{database}/documents {

            // Helper function to get user's teamId and role
            function getUserData(userId) {
              return get(/databases/$(database)/documents/users/$(userId)).data;
            }
            function isSignedIn() {
              return request.auth != null;
            }
            function isUserTeamMember(teamId) {
              return isSignedIn() && getUserData(request.auth.uid).teamId == teamId;
            }
            function isUserTeamAdmin(teamId) {
              return isUserTeamMember(teamId) && getUserData(request.auth.uid).role == 'admin';
            }

            // Teams collection
            match /teams/{teamId} {
              allow read: if isUserTeamMember(teamId);
              allow create: if isSignedIn() && request.resource.data.ownerUid == request.auth.uid;
              allow update: if isUserTeamAdmin(teamId) && request.resource.data.ownerUid == resource.data.ownerUid; // Prevent ownerUid change by client
              // Delete usually handled by backend/admin functions
            }

            // Users collection
            match /users/{userId} {
              allow read: if isSignedIn(); // Or more restrictive: isUserTeamMember(resource.data.teamId)
              allow create: if isSignedIn() && request.auth.uid == userId; // User creating their own profile
              allow update: if isSignedIn() &&
                               (request.auth.uid == userId || // Own profile (restrict fields like role/teamId via rules on request.resource.data)
                                (isUserTeamAdmin(resource.data.teamId) && request.resource.data.teamId == resource.data.teamId)); // Admin updating users in their team
              allow delete: if isUserTeamAdmin(resource.data.teamId) && request.auth.uid != userId; // Admin deleting others in their team
            }

            // Matches subcollection
            match /teams/{teamId}/matches/{matchId} {
              allow read: if isUserTeamMember(teamId);
              allow create, update, delete: if isUserTeamAdmin(teamId);
            }

            // Trainings subcollection
            match /teams/{teamId}/trainings/{trainingId} {
              allow read: if isUserTeamMember(teamId);
              allow create, update, delete: if isUserTeamAdmin(teamId);
            }
          }
        }
        ```
    *   **Test your security rules thoroughly** using the Firebase console's Rules Playground before deploying your app widely.

By following this structure and implementing robust security rules, your TeamEase application will have a solid foundation for managing team data securely and efficiently.
The existing application code in `src/services/` is designed to work with this Firestore structure.
    