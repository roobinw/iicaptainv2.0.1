
# Firestore Database Setup and Structure for iiCaptain

This guide explains how to set up your Firestore database in the Firebase console and outlines the data structure that the iiCaptain application is designed to work with.

## 1. Creating Firestore Database in Firebase Console

If you haven't already, you need to create a Firestore database instance for your Firebase project:

1.  **Go to your Firebase Project:** Open the [Firebase Console](https://console.firebase.google.com/) and select your project.
2.  **Navigate to Firestore Database:** In the left-hand navigation pane, under "Build", click on "Firestore Database".
3.  **Create Database:**
    *   Click the "Create database" button.
    *   **Choose a mode:**
        *   **Production mode:** Starts with secure rules (denying all access by default). This is recommended. You will need to add security rules later (see section 4).
        *   **Test mode:** Starts with open rules (allowing all reads/writes for 30 days). Useful for initial development but **must be secured before production.**
    *   **Choose a location:** Select the region where your data will be stored. This cannot be changed later. Choose a location close to your users.
    *   Click "Enable".

Your Firestore database is now ready.

## 2. Firestore Data Structure

The application uses the following collection and subcollection structure to support multi-tenancy (each team has its own environment) and roles (admin, member).

### Collection: `teams`

This is a top-level collection where each document represents a unique team.

*   **Document ID:** Auto-generated by Firestore (this ID is referred to as `teamId` in the application).
*   **Fields:**
    *   `name`: (String) The name of the team (e.g., "The Eagles").
    *   `ownerUid`: (String) The Firebase Auth UID of the user who created/owns the team. This user is typically the first admin.
    *   `createdAt`: (Timestamp) Server timestamp indicating when the team was created.
    *   `inviteCode`: (String) A shareable code for new members to join this team. Generated on team creation, resettable by admins.

*   **Subcollection of `teams/{teamId}`: `matches`**
    *   Stores all matches for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `date`: (String) Match date in "yyyy-MM-dd" format.
        *   `time`: (String) Match time in "HH:mm" format (24-hour).
        *   `opponent`: (String) Name of the opponent team.
        *   `location`: (String, optional) Venue of the match.
        *   `attendance`: (Map) Stores member attendance.
            *   Keys: Member Firebase Auth UIDs (String).
            *   Values: (String) "present", "absent", "excused", or "unknown".
            *   Example: `{"firebaseUserUid1": "present", "firebaseUserUid2": "absent"}`
        *   `isArchived`: (Boolean) `true` if the match is archived, `false` otherwise. Defaults to `false`.
    *   **Subcollection of `matches/{matchId}`: `playerStats`**
        * Stores individual player statistics for this specific match.
        * **Document ID:** Player's Firebase Auth UID (String).
        * **Fields:**
            * `playerId`: (String) Firebase Auth UID of the player. (Matches the Document ID).
            * `goals`: (Number) Goals scored by the player in this match. Defaults to 0.
            * `assists`: (Number) Assists made by the player in this match. Defaults to 0.
            * `saves`: (Number) Saves made by the player (if applicable, e.g., goalkeeper). Defaults to 0.
            * `yellowCards`: (Number) Number of yellow cards received. Defaults to 0.
            * `redCards`: (Number) Number of red cards received. Defaults to 0.
            * `updatedAt`: (Timestamp) Server timestamp of when these stats were last updated.
    *   **Subcollection of `matches/{matchId}`: `availability`**
        *   Stores individual player availability for this specific match.
        *   **Document ID:** Player's Firebase Auth UID (String).
        *   **Fields:**
            *   `playerId`: (String) Firebase Auth UID of the player (matches Document ID).
            *   `status`: (String) Enum: "available", "unavailable", "maybe", "unknown".
            *   `notes`: (String, optional) Any notes regarding availability.
            *   `updatedAt`: (Timestamp) Server timestamp of when this availability was last updated.


*   **Subcollection of `teams/{teamId}`: `trainings`**
    *   Stores all training sessions for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `date`: (String) Training date in "yyyy-MM-dd" format.
        *   `time`: (String) Training time in "HH:mm" format (24-hour).
        *   `location`: (String) Location of the training session.
        *   `description`: (String, optional) Additional details about the training.
        *   `attendance`: (Map) Stores member attendance (same structure as in `matches`).
        *   `isArchived`: (Boolean) `true` if the training is archived, `false` otherwise. Defaults to `false`.
    *   **Subcollection of `trainings/{trainingId}`: `availability`**
        *   Stores individual player availability for this specific training.
        *   **Document ID:** Player's Firebase Auth UID (String).
        *   **Fields:**
            *   `playerId`: (String) Firebase Auth UID of the player (matches Document ID).
            *   `status`: (String) Enum: "available", "unavailable", "maybe", "unknown".
            *   `notes`: (String, optional) Any notes regarding availability.
            *   `updatedAt`: (Timestamp) Server timestamp of when this availability was last updated.

*   **Subcollection of `teams/{teamId}`: `refereeingAssignments`**
    *   Stores all refereeing assignments for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `date`: (String) Assignment date in "yyyy-MM-dd" format.
        *   `time`: (String) Assignment time in "HH:mm" format (24-hour).
        *   `homeTeam`: (String, optional) The name of the home team for the match being refereed.
        *   `assignedPlayerUids`: (Array of Strings) Firebase Auth UIDs of the members assigned to referee.
        *   `notes`: (String, optional) Additional details or instructions for the assignment.
        *   `isArchived`: (Boolean) `true` if the assignment is archived, `false` otherwise. Defaults to `false`.

*   **Subcollection of `teams/{teamId}`: `messages`**
    *   Stores all team messages for the dashboard message board.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `content`: (String) The content of the message.
        *   `authorUid`: (String) Firebase Auth UID of the admin who posted the message.
        *   `authorName`: (String) Name of the admin at the time of posting.
        *   `createdAt`: (Timestamp) Server timestamp indicating when the message was created.
        *   `teamId`: (String) The ID of the team this message belongs to (matches parent `teamId`).
        *   `isArchived`: (Boolean) `true` if the message is archived, `false` otherwise. Defaults to `false`.

*   **Subcollection of `teams/{teamId}`: `opponents`**
    *   Stores all opponents for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `name`: (String) The name of the opponent team.
        *   `contactPerson`: (String, optional) Name of a contact person for the opponent.
        *   `contactEmail`: (String, optional) Email of the contact person.
        *   `contactPhone`: (String, optional) Phone number of the contact person.
        *   `homeGround`: (String, optional) Opponent's usual home ground/location.
        *   `createdAt`: (Timestamp) Server timestamp indicating when the opponent was added.

*   **Subcollection of `teams/{teamId}`: `equipment`**
    *   Stores all equipment items for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `name`: (String) The name of the equipment item (e.g., "Size 5 Balls", "Training Cones").
        *   `description`: (String, optional) Further details about the equipment.
        *   `quantity`: (Number) How many of this item the team possesses.
        *   `condition`: (String, enum: "new", "good", "fair", "poor") The current condition of the equipment.
        *   `createdAt`: (Timestamp) Server timestamp indicating when the equipment was added.


### Collection: `users`

This is a top-level collection where each document represents a user profile.

*   **Document ID:** This is **always** the Firebase Auth UID of the user.
*   **Fields:**
    *   `uid`: (String) The Firebase Auth UID. This field must match the document ID.
    *   `name`: (String) Full name of the user.
    *   `email`: (String) Email address of the user (stored in lowercase).
    *   `isAdmin`: (Boolean) `true` if the user is an admin for their team, `false` otherwise.
    *   `canParticipateInMatches`: (Boolean) `true` if the member is eligible for matches. Defaults to `true`.
    *   `canParticipateInTrainings`: (Boolean) `true` if the member is eligible for trainings. Defaults to `true`.
    *   `canBeAssignedRefereeing`: (Boolean) `true` if the member can be assigned refereeing duties. Defaults to `true`.
    *   `isCoach`: (Boolean) `true` if the member has coaching responsibilities. Defaults to `false`.
    *   `isTrainer`: (Boolean) `true` if the member has trainer/physio responsibilities. Defaults to `false`.
    *   `teamId`: (String) The ID of the team (from the `teams` collection) that this user belongs to. This is crucial for multi-tenancy.
    *   `avatarUrl`: (String, optional) URL to the user's profile picture.
    *   `createdAt`: (Timestamp) Server timestamp indicating when the user profile was created.
    *   `jerseyNumber`: (Number, optional) Player's jersey number.
    *   `position`: (String, optional) Player's preferred position.
    *   `dateOfBirth`: (String, "yyyy-MM-dd", optional) Player's date of birth.
    *   `emergencyContactName`: (String, optional) Name of emergency contact.
    *   `emergencyContactPhone`: (String, optional) Phone of emergency contact.
    *   `medicalNotes`: (String, optional) Any relevant medical notes.


### Collection: `tickets`

This is a top-level collection where each document represents a support ticket.

*   **Document ID:** Auto-generated by Firestore.
*   **Fields:**
    *   `userId`: (String) The Firebase Auth UID of the user who submitted the ticket.
    *   `userName`: (String) The name of the user at the time of submission.
    *   `userEmail`: (String) The email of the user at the time of submission.
    *   `teamId`: (String, optional) The `teamId` of the user, if they belong to one.
    *   `subject`: (String) The subject line of the support ticket.
    *   `message`: (String) The detailed message content of the support ticket.
    *   `status`: (String) The current status of the ticket (e.g., "open", "in-progress", "resolved", "closed"). Defaults to "open".
    *   `createdAt`: (Timestamp) Server timestamp indicating when the ticket was created.
    *   `updatedAt`: (Timestamp) Server timestamp, updated when the ticket status or content changes.


## 3. Example Document Structure

**Example `teams` document (`/teams/uniqueTeamId123`):**
```json
{
  "name": "The Roaring Lions",
  "ownerUid": "firebaseUserUidAbc",
  "inviteCode": "LIONS01",
  "createdAt": "October 26, 2023 at 10:00:00 AM UTC+2"
}
```

**Example `matches` subcollection document (`/teams/uniqueTeamId123/matches/matchId456`):**
```json
{
  "date": "2023-11-05",
  "time": "15:00",
  "opponent": "The Sharks",
  "location": "Community Stadium",
  "attendance": {
    "memberFirebaseUidXyz": "present",
    "memberFirebaseUidPqr": "excused"
  },
  "isArchived": false
}
```
**Example `playerStats` subcollection document (`/teams/uniqueTeamId123/matches/matchId456/playerStats/memberFirebaseUidXyz`):**
```json
{
  "playerId": "memberFirebaseUidXyz",
  "goals": 2,
  "assists": 1,
  "saves": 0,
  "yellowCards": 0,
  "redCards": 0,
  "updatedAt": "November 05, 2023 at 17:00:00 PM UTC+1"
}
```
**Example `availability` subcollection document (`/teams/uniqueTeamId123/matches/matchId456/availability/memberFirebaseUidXyz`):**
```json
{
  "playerId": "memberFirebaseUidXyz",
  "status": "available",
  "notes": "Feeling great!",
  "updatedAt": "November 02, 2023 at 09:00:00 AM UTC+1"
}
```


**Example `trainings` subcollection document (`/teams/uniqueTeamId123/trainings/trainingId789`):**
```json
{
  "date": "2023-11-06",
  "time": "19:00",
  "location": "Main Training Field",
  "description": "Tactical drills and fitness.",
  "attendance": {
    "memberFirebaseUidXyz": "present"
  },
  "isArchived": false
}
```

**Example `refereeingAssignments` subcollection document (`/teams/uniqueTeamId123/refereeingAssignments/assignmentId789`):**
```json
{
  "date": "2023-11-12",
  "time": "10:00",
  "homeTeam": "The Bears",
  "assignedPlayerUids": ["memberFirebaseUidMno", "memberFirebaseUidJkl"],
  "notes": "Remember to bring whistles and cards. Arrive 30 mins early.",
  "isArchived": false
}
```

**Example `messages` subcollection document (`/teams/uniqueTeamId123/messages/messageIdAbc`):**
```json
{
  "content": "Important: Training is cancelled for this Friday due to bad weather.",
  "authorUid": "firebaseUserUidAbc",
  "authorName": "Jane Doe (Admin)",
  "createdAt": "November 15, 2023 at 09:30:00 AM UTC+1",
  "teamId": "uniqueTeamId123",
  "isArchived": false
}
```

**Example `opponents` subcollection document (`/teams/uniqueTeamId123/opponents/opponentIdDef`):**
```json
{
  "name": "The Sharks",
  "contactPerson": "Coach Dave",
  "contactEmail": "dave@thesharks.com",
  "contactPhone": "555-1234",
  "homeGround": "Ocean Arena",
  "createdAt": "November 20, 2023 at 11:00:00 AM UTC+1"
}
```

**Example `equipment` subcollection document (`/teams/uniqueTeamId123/equipment/equipmentIdGhi`):**
```json
{
  "name": "Size 5 Match Balls",
  "description": "Official league quality balls.",
  "quantity": 10,
  "condition": "good",
  "createdAt": "November 21, 2023 at 02:00:00 PM UTC+1"
}
```

**Example `users` document (`/users/firebaseUserUidAbc` where `firebaseUserUidAbc` is the Firebase Auth UID):**
```json
{
  "uid": "firebaseUserUidAbc",
  "name": "Jane Doe",
  "email": "jane.doe@example.com",
  "isAdmin": true,
  "canParticipateInMatches": true,
  "canParticipateInTrainings": true,
  "canBeAssignedRefereeing": false,
  "isCoach": true,
  "isTrainer": false,
  "teamId": "uniqueTeamId123",
  "avatarUrl": "https://picsum.photos/seed/jane.doe@example.com/80/80",
  "createdAt": "October 26, 2023 at 09:55:00 AM UTC+2",
  "jerseyNumber": 10,
  "position": "Forward"
}
```
**Example `users` document for a member added by an admin (`/users/newMemberAuthUid789`):**
```json
{
  "uid": "newMemberAuthUid789",
  "name": "John Member",
  "email": "john.member@example.com",
  "isAdmin": false,
  "canParticipateInMatches": true,
  "canParticipateInTrainings": true,
  "canBeAssignedRefereeing": true,
  "isCoach": false,
  "isTrainer": false,
  "teamId": "uniqueTeamId123",
  "avatarUrl": "https://picsum.photos/seed/john.member@example.com/80/80",
  "createdAt": "October 27, 2023 at 11:00:00 AM UTC+2"
}
```

**Example `tickets` document (`/tickets/ticketId789`):**
```json
{
  "userId": "firebaseUserUidAbc",
  "userName": "Jane Doe",
  "userEmail": "jane.doe@example.com",
  "teamId": "uniqueTeamId123",
  "subject": "Cannot update match details",
  "message": "I'm trying to update the location for our next match, but the save button is greyed out. Can you please help?",
  "status": "open",
  "createdAt": "November 10, 2023 at 02:30:00 PM UTC+1",
  "updatedAt": "November 10, 2023 at 02:30:00 PM UTC+1"
}
```

## 4. Initial Data and Security Rules

*   **Initial Data:**
    *   When a new user signs up via the app with no invite code, they provide a **Team Name** and their **own name**.
    *   The app then:
        1.  Creates their Firebase Authentication account.
        2.  Creates a new team document in the `teams` collection with the provided team name, a generated `inviteCode`, and sets the new user as `ownerUid`.
        3.  Creates their user profile document in the `users` collection, linking them to the newly created `teamId` and setting `isAdmin: true` and default participation booleans.
    *   When a new user signs up with a valid `inviteCode`:
        1.  Creates their Firebase Authentication account.
        2.  Finds the `teamId` associated with the `inviteCode`.
        3.  Creates their user profile document in the `users` collection, linking them to the found `teamId` and setting `isAdmin: false` and default participation booleans.
    *   Admins can edit member profiles (including their boolean roles/permissions) from the Team Settings page.
    *   Matches, Trainings, and Refereeing Assignments are added by team admins. They default to `isArchived: false`.
    *   Messages are added by team admins. They default to `isArchived: false`.
    *   Opponents and Equipment are managed by admins within their team's subcollections.
    *   Support tickets are created by any authenticated user.

*   **Firestore Security Rules (VERY IMPORTANT):**
    *   Default security rules are restrictive. You **must** configure Firestore Security Rules.
    *   These rules enforce multi-tenancy and role-based access.
    *   **If you encounter "Missing or insufficient permissions" errors, double-check these rules and user document data.**

    **Security Rules:**
    ```firestore-rules
    rules_version = '2';

    service cloud.firestore {
      match /databases/{database}/documents {

        // Helper function to get requesting user's data (isAdmin, teamId, etc.)
        // Returns user data if document exists, otherwise null.
        function getUserAuthData() {
          return (request.auth != null && request.auth.uid != null && exists(path('/databases/' + database + '/documents/users/' + request.auth.uid)))
            ? get(path('/databases/' + database + '/documents/users/' + request.auth.uid)).data
            : null;
        }

        // Helper: Is the user signed in?
        function isSignedIn() {
          return request.auth != null;
        }

        // Helper: Does the requesting user belong to the specified teamId?
        function isUserTeamMember(teamId) {
          let userAuthRecord = getUserAuthData();
          return isSignedIn() && userAuthRecord != null && userAuthRecord.teamId == teamId;
        }

        // Helper: Is the requesting user an admin of the specified teamId?
        function isUserTeamAdmin(teamId) {
          let userAuthData = getUserAuthData(); 
          return isUserTeamMember(teamId) && userAuthData != null && userAuthData.isAdmin == true;
        }
        
        // Helper: Is the user creating/modifying their own document?
        function isOwner(userId) {
          return request.auth != null && request.auth.uid == userId;
        }

        // Teams collection
        match /teams/{teamId} {
          // Any SIGNED IN user can read team details (e.g., to verify an invite code during signup or fetch team name).
          allow read: if isSignedIn(); 
          // Only an authenticated user can create a team, and they must be its owner.
          // inviteCode must be set on create.
          allow create: if isSignedIn() && 
                           request.auth.uid == request.resource.data.ownerUid &&
                           request.resource.data.inviteCode != null;
          // Only an admin of this team can update its name or reset its inviteCode.
          // ownerUid should not be changed by client.
          allow update: if isUserTeamAdmin(teamId) && 
                           request.resource.data.ownerUid == resource.data.ownerUid &&
                           (request.resource.data.name != resource.data.name || 
                            request.resource.data.inviteCode != resource.data.inviteCode);
          allow delete: if false; // Deleting teams is typically a backend/admin function
        }

        // Users collection
        match /users/{userId} {
          // Any signed-in user can read any user profile within their own team.
          // For broader access (e.g., admin viewing any profile for assignment), rules might need adjustment or be handled by specific queries.
          allow read: if isSignedIn() && 
                         (isOwner(userId) || (getUserAuthData() != null && resource.data.teamId == getUserAuthData().teamId));


          // Allow creation of user documents under two conditions:
          // 1. A user creating their own profile (documentId {userId} == auth.uid) during signup.
          // 2. (REMOVED - Admins no longer create auth accounts directly for other users)
          allow create: if isSignedIn() &&
                          (
                            // Case 1: User creating their own profile (e.g., during signup)
                            isOwner(userId) && 
                            request.resource.data.uid == request.auth.uid && // uid field must match auth uid
                            request.resource.data.email != null && 
                            request.resource.data.name != null &&
                            request.resource.data.teamId != null && // Set by signup flow
                            // Default roles set by signup flow
                            request.resource.data.isAdmin != null && 
                            request.resource.data.canParticipateInMatches != null &&
                            request.resource.data.canParticipateInTrainings != null &&
                            request.resource.data.canBeAssignedRefereeing != null &&
                            request.resource.data.isCoach != null &&
                            request.resource.data.isTrainer != null
                          );

          // A user can update their own profile (e.g., name, avatarUrl, non-admin booleans).
          // An admin can update profiles of users within their own team (including all boolean flags).
          // Critical fields like teamId and uid should be protected from arbitrary client-side changes.
          allow update: if isSignedIn() &&
                          (
                            // User is updating their own profile
                            (isOwner(userId) &&
                              request.resource.data.uid == resource.data.uid && // uid cannot change
                              request.resource.data.teamId == resource.data.teamId && // teamId cannot change by self
                              request.resource.data.email == resource.data.email && // email cannot change by self
                              // User cannot change their own isAdmin status
                              request.resource.data.isAdmin == resource.data.isAdmin
                            ) || 
                            // Admin is updating another user's profile within their team
                            (isUserTeamAdmin(resource.data.teamId) && // Admin of the target user's team
                             resource.data.teamId == getUserAuthData().teamId && // Admin must be in the same team as the target user
                             request.resource.data.teamId == resource.data.teamId && // Admin is not changing the target user's teamId
                             request.resource.data.uid == resource.data.uid && // UID field must not change
                             request.resource.data.email == resource.data.email // Email cannot be changed by admin
                             // Admin can change all other fields, including isAdmin for other users
                            ) 
                          );
          
          // An admin can delete user profiles from their team (except their own).
          // This rule only deletes the Firestore document, not the Firebase Auth account.
          allow delete: if isUserTeamAdmin(resource.data.teamId) && 
                          resource.data.teamId == getUserAuthData().teamId && 
                          userId != request.auth.uid; 
        }

        // Matches subcollection
        match /teams/{teamId}/matches/{matchId} {
          allow read: if isUserTeamMember(teamId);
          allow create: if isUserTeamAdmin(teamId) && request.resource.data.isArchived == false;
          allow update: if isUserTeamAdmin(teamId); // Simplified, can be refined if specific fields need protection
          allow delete: if isUserTeamAdmin(teamId);

          // Player Statistics subcollection
          match /playerStats/{playerId} {
            allow read: if isUserTeamMember(teamId);
            // Only admins can write/update player stats for their team's matches
            allow write, update, delete: if isUserTeamAdmin(teamId);
          }

          // Availability subcollection
          match /availability/{playerId} {
            // Player can read/write their own availability for an event in their team. Admin can read any.
            allow read: if isUserTeamMember(teamId);
            allow write: if isUserTeamMember(teamId) && isOwner(playerId); // Player setting their own status
            // Admin override for availability could be added here if needed
            // allow write: if isUserTeamAdmin(teamId); // Example for admin override
          }
        }

        // playerStats collection group query rule (for aggregate stats)
        match /{pathSegments=**}/playerStats/{statId} {
          allow read: if isSignedIn() &&
                         pathSegments != null &&
                         pathSegments.size() >= 2 &&
                         pathSegments[0] == 'teams' &&
                         isUserTeamMember(pathSegments[1]); // pathSegments[1] should be the teamId
        }


        // Trainings subcollection
        match /teams/{teamId}/trainings/{trainingId} {
          allow read: if isUserTeamMember(teamId);
          allow create: if isUserTeamAdmin(teamId) && request.resource.data.isArchived == false;
          allow update: if isUserTeamAdmin(teamId);
          allow delete: if isUserTeamAdmin(teamId);

          // Availability subcollection for trainings
          match /availability/{playerId} {
            allow read: if isUserTeamMember(teamId);
            allow write: if isUserTeamMember(teamId) && isOwner(playerId);
          }
        }

        // Refereeing Assignments subcollection
        match /teams/{teamId}/refereeingAssignments/{assignmentId} {
          allow read: if isUserTeamMember(teamId);
          allow create: if isUserTeamAdmin(teamId) && request.resource.data.isArchived == false;
          allow update: if isUserTeamAdmin(teamId);
          allow delete: if isUserTeamAdmin(teamId);
        }

        // Messages subcollection
        match /teams/{teamId}/messages/{messageId} {
          allow read: if isUserTeamMember(teamId);
          allow create: if isUserTeamAdmin(teamId) && 
                           request.resource.data.authorUid == request.auth.uid &&
                           request.resource.data.teamId == teamId &&
                           request.resource.data.isArchived == false;
          allow update: if isUserTeamAdmin(teamId) &&
                           request.resource.data.authorUid == resource.data.authorUid &&
                           request.resource.data.teamId == resource.data.teamId &&
                           request.resource.data.content == resource.data.content &&
                           request.resource.data.authorName == resource.data.authorName &&
                           request.resource.data.createdAt.toMillis() == resource.data.createdAt.toMillis();
          allow delete: if isUserTeamAdmin(teamId);
        }

        // Opponents subcollection
        match /teams/{teamId}/opponents/{opponentId} {
          allow read: if isUserTeamMember(teamId);
          allow create, update, delete: if isUserTeamAdmin(teamId);
        }

        // Equipment subcollection
        match /teams/{teamId}/equipment/{equipmentId} {
          allow read: if isUserTeamMember(teamId);
          allow create, update, delete: if isUserTeamAdmin(teamId);
        }
        
        // Tickets collection
        match /tickets/{ticketId} {
          allow create: if isSignedIn() &&
                          request.resource.data.userId == request.auth.uid &&
                          request.resource.data.status == 'open';
          allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
          allow update: if isSignedIn() && resource.data.userId == request.auth.uid &&
                          request.resource.data.userId == resource.data.userId &&
                          request.resource.data.createdAt.toMillis() == resource.data.createdAt.toMillis();
          allow delete: if false; 
        }
      }
    }
    ```
    *   **Test your security rules thoroughly** using the Firebase console's Rules Playground.

## 5. Required Firestore Indexes

*   **Collection:** `teams`
    *   **Fields:**
        1. `inviteCode` (Ascending)
    *   **Query scope:** Collection (For looking up teams by invite code during signup)

*   **Collection Group:** `matches`
    *   **Fields:**
        1.  `isArchived` (Ascending)
        2.  `date` (Ascending)
        3.  `time` (Ascending)
    *   **Query scope:** Collection group

*   **Collection Group:** `trainings`
    *   **Fields:**
        1.  `isArchived` (Ascending)
        2.  `date` (Ascending)
        3.  `time` (Ascending)
    *   **Query scope:** Collection group

*   **Collection Group:** `refereeingAssignments`
    *   **Fields:**
        1.  `isArchived` (Ascending)
        2.  `date` (Ascending)
        3.  `time` (Ascending)
    *   **Query scope:** Collection group

*   **Collection Group:** `messages`
    *   **Fields:**
        1.  `isArchived` (Ascending)
        2.  `createdAt` (Descending)
    *   **Query scope:** Collection group

*   **Collection Group:** `opponents` (Under `teams/{teamId}/opponents`)
    *   **Fields:**
        1.  `name` (Ascending)
    *   **Query scope:** Collection group

*   **Collection Group:** `equipment` (Under `teams/{teamId}/equipment`)
    *   **Fields:**
        1.  `name` (Ascending)
    *   **Query scope:** Collection group
    
*   **Collection Group:** `playerStats` (Under `teams/{teamId}/matches/{matchId}/playerStats`)
    *   **Fields:**
        1. `playerId` (Ascending)
    *   **Query scope:** Collection group (For aggregating player stats across all matches)

*   **Collection Group:** `availability` (For `matches` subcollection)
    *   **Fields:**
        1. `eventId` (Ascending) // Assuming you add eventId to availability docs
        2. `status` (Ascending)
    *   **Query scope:** Collection group
    *   *(Note: If eventId is not directly stored, specific queries for a single event's availability might not need a complex index if just fetching all docs for that event's subcollection.)*

*   **Collection Group:** `availability` (For `trainings` subcollection - same as above if structure is identical)

*   **Collection:** `users`
    *   **Fields:**
        1. `teamId` (Ascending)
        2. `name` (Ascending)
    *   **Query scope:** Collection

*   **Collection:** `users`
    *   **Fields:**
        1. `teamId` (Ascending)
        2. `isAdmin` (Ascending) // If you need to query admins within a team
        3. `name` (Ascending)
    *   **Query scope:** Collection

*   **Collection:** `tickets`
    *   **Fields:**
        1. `userId` (Ascending)
        2. `createdAt` (Descending)
    *   **Query scope:** Collection

**Note on Index Creation Time:** Composite indexes can take a few minutes to build.

By following this structure, implementing robust security rules, and creating the necessary indexes, your iiCaptain application will have a solid foundation for managing team data securely and efficiently.

