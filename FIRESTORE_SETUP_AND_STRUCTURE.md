
# Firestore Database Setup and Structure for TeamEase

This guide explains how to set up your Firestore database in the Firebase console and outlines the data structure that the TeamEase application is designed to work with.

## 1. Creating Firestore Database in Firebase Console

If you haven't already, you need to create a Firestore database instance for your Firebase project:

1.  **Go to your Firebase Project:** Open the [Firebase Console](https://console.firebase.google.com/) and select your project.
2.  **Navigate to Firestore Database:** In the left-hand navigation pane, under "Build", click on "Firestore Database".
3.  **Create Database:**
    *   Click the "Create database" button.
    *   **Choose a mode:**
        *   **Production mode:** Starts with secure rules (denying all access by default). This is recommended. You will need to add security rules later (see section 4).
        *   **Test mode:** Starts with open rules (allowing all reads/writes for 30 days). Useful for initial development but **must be secured before production.**
    *   **Choose a location:** Select the region where your data will be stored. This cannot be changed later. Choose a location close to your users.
    *   Click "Enable".

Your Firestore database is now ready.

## 2. Firestore Data Structure

The application uses the following collection and subcollection structure to support multi-tenancy (each team has its own environment) and roles (admin, player).

### Collection: `teams`

This is a top-level collection where each document represents a unique team.

*   **Document ID:** Auto-generated by Firestore (this ID is referred to as `teamId` in the application).
*   **Fields:**
    *   `name`: (String) The name of the team (e.g., "The Eagles").
    *   `ownerUid`: (String) The Firebase Auth UID of the user who created/owns the team. This user is typically the first admin.
    *   `createdAt`: (Timestamp) Server timestamp indicating when the team was created.

*   **Subcollection of `teams/{teamId}`: `matches`**
    *   Stores all matches for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `date`: (String) Match date in "yyyy-MM-dd" format.
        *   `time`: (String) Match time in "HH:mm" format (24-hour).
        *   `opponent`: (String) Name of the opponent team.
        *   `location`: (String, optional) Venue of the match.
        *   `attendance`: (Map) Stores player attendance.
            *   Keys: Player Firebase Auth UIDs (String).
            *   Values: (String) "present", "absent", "excused", or "unknown".
            *   Example: `{"firebaseUserUid1": "present", "firebaseUserUid2": "absent"}`
        *   `order`: (Number, optional) For drag-and-drop reordering of matches. Initialized to current list length.

*   **Subcollection of `teams/{teamId}`: `trainings`**
    *   Stores all training sessions for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `date`: (String) Training date in "yyyy-MM-dd" format.
        *   `time`: (String) Training time in "HH:mm" format (24-hour).
        *   `location`: (String) Location of the training session.
        *   `description`: (String, optional) Additional details about the training.
        *   `attendance`: (Map) Stores player attendance (same structure as in `matches`).
        *   `order`: (Number, optional) For drag-and-drop reordering of training sessions. Initialized to current list length.

### Collection: `users`

This is a top-level collection where each document represents a user profile.

*   **Document ID:** Should be the Firebase Auth UID of the user.
*   **Fields:**
    *   `uid`: (String) The Firebase Auth UID (same as the document ID, useful for querying).
    *   `name`: (String) Full name of the user.
    *   `email`: (String) Email address of the user (stored in lowercase).
    *   `role`: (String) User's role within their team. Can be "admin" or "player".
    *   `teamId`: (String) The ID of the team (from the `teams` collection) that this user belongs to. This is crucial for multi-tenancy.
    *   `avatarUrl`: (String, optional) URL to the user's profile picture.
    *   `createdAt`: (Timestamp) Server timestamp indicating when the user profile was created.

## 3. Example Document Structure

**Example `teams` document (`/teams/uniqueTeamId123`):**
```json
{
  "name": "The Roaring Lions",
  "ownerUid": "firebaseUserUidAbc",
  "createdAt": "October 26, 2023 at 10:00:00 AM UTC+2"
}
```

**Example `matches` subcollection document (`/teams/uniqueTeamId123/matches/matchId456`):**
```json
{
  "date": "2023-11-05",
  "time": "15:00",
  "opponent": "The Sharks",
  "location": "Community Stadium",
  "attendance": {
    "playerFirebaseUidXyz": "present",
    "playerFirebaseUidPqr": "excused"
  },
  "order": 0
}
```

**Example `users` document (`/users/firebaseUserUidAbc` where `firebaseUserUidAbc` is the Firebase Auth UID):**
```json
{
  "uid": "firebaseUserUidAbc",
  "name": "Jane Doe",
  "email": "jane.doe@example.com",
  "role": "admin",
  "teamId": "uniqueTeamId123",
  "avatarUrl": "https://picsum.photos/seed/jane.doe@example.com/80/80",
  "createdAt": "October 26, 2023 at 09:55:00 AM UTC+2"
}
```

## 4. Initial Data and Security Rules

*   **Initial Data:**
    *   When a new user signs up via the app, they also provide a **Team Name**.
    *   The app then:
        1.  Creates their Firebase Authentication account.
        2.  Creates a new team document in the `teams` collection with the provided name and sets the new user as `ownerUid`.
        3.  Creates their user profile document in the `users` collection, linking them to the newly created `teamId` and assigning them the `role: "admin"`.
    *   Admins can then add other player profiles to their team via the "Players" page in the app. This creates `users` documents for those players, with `role: "player"` and the admin's `teamId`.
    *   Matches and Trainings are added by team admins through the app into their respective team's subcollections.

*   **Firestore Security Rules (VERY IMPORTANT):**
    *   Default security rules (especially in "Production mode") are highly restrictive. You **must** configure Firestore Security Rules.
    *   These rules enforce multi-tenancy (a user can only access data for their own team) and role-based access (only an admin can create/modify team-wide data like matches or other player profiles within their team).

    **Example Security Rules (Updated with more robust helpers):**
    ```firestore-rules
    rules_version = '2';
    service cloud.firestore {
      match /databases/{database}/documents {

        // Helper function to get requesting user's data (role, teamId)
        // Returns user data if document exists, otherwise null.
        function getUserAuthData() {
          // Construct the path string correctly using string concatenation for dynamic parts like request.auth.uid
          let userDocumentPath = path('/databases/$(database)/documents/users/' + request.auth.uid);
          return exists(userDocumentPath) ? get(userDocumentPath).data : null;
        }

        // Helper: Is the user signed in?
        function isSignedIn() {
          return request.auth != null;
        }

        // Helper: Does the requesting user belong to the specified teamId?
        function isUserTeamMember(teamId) {
          let userAuthRecord = getUserAuthData();
          return isSignedIn() && userAuthRecord != null && userAuthRecord.teamId == teamId;
        }

        // Helper: Is the requesting user an admin of the specified teamId?
        function isUserTeamAdmin(teamId) {
          // isUserTeamMember already checks isSignedIn and if userAuthRecord is null
          return isUserTeamMember(teamId) && getUserAuthData().role == 'admin';
        }
        
        // Helper: Is the user creating/modifying their own document?
        function isOwner(userId) {
          return request.auth != null && request.auth.uid == userId;
        }

        // Teams collection
        match /teams/{teamId} {
          // Any authenticated user who is part of this team can read team details.
          allow read: if isUserTeamMember(teamId);
          // Only an authenticated user can create a team, and they must be its owner.
          // teamId in request.resource.data should match what's being created.
          allow create: if isSignedIn() && request.auth.uid == request.resource.data.ownerUid;
          // Only an admin of this team can update its name (ownerUid should not be changed by client).
          allow update: if isUserTeamAdmin(teamId) && request.resource.data.ownerUid == resource.data.ownerUid;
          // Deleting teams is typically a backend/admin function, not client-side.
          allow delete: if false; 
        }

        // Users collection
        match /users/{userId} {
          // Any signed-in user can read any user profile (e.g., to see names for attendance or their own profile).
          allow read: if isSignedIn();

          // A user can create their own profile document.
          // This is handled during signup where teamId and role are also set.
          allow create: if isOwner(userId) && 
                          request.resource.data.uid == userId &&
                          request.resource.data.email != null && 
                          request.resource.data.name != null &&
                          request.resource.data.role != null &&
                          request.resource.data.teamId != null; 
                          // teamId and role validity checked during team creation by admin on signup.

          // A user can update their own profile (e.g., name, avatarUrl).
          // An admin can update profiles of users within their own team.
          // Critical fields like 'role' and 'teamId' should be protected from arbitrary client-side changes by non-admins or on self-update.
          allow update: if isSignedIn() &&
                          (
                            (isOwner(userId) && 
                              !(request.resource.data.role != resource.data.role || 
                                request.resource.data.teamId != resource.data.teamId || 
                                request.resource.data.email != resource.data.email    
                               )) || 
                            (isUserTeamAdmin(resource.data.teamId) && 
                             request.resource.data.teamId == resource.data.teamId && 
                             userId != request.auth.uid 
                            ) 
                          );
          
          // An admin can delete user profiles from their team (except their own).
          // resource.data.teamId refers to the teamId of the user being deleted.
          allow delete: if isUserTeamAdmin(resource.data.teamId) && userId != request.auth.uid;
        }

        // Matches subcollection (nested under a specific team)
        match /teams/{teamId}/matches/{matchId} {
          // Any member of this team can read matches.
          allow read: if isUserTeamMember(teamId);
          // Only an admin of this team can create, update, or delete matches.
          allow create, update, delete: if isUserTeamAdmin(teamId);
        }

        // Trainings subcollection (nested under a specific team)
        match /teams/{teamId}/trainings/{trainingId} {
          // Any member of this team can read trainings.
          allow read: if isUserTeamMember(teamId);
          // Only an admin of this team can create, update, or delete trainings.
          allow create, update, delete: if isUserTeamAdmin(teamId);
        }
      }
    }
    ```
    *   **Test your security rules thoroughly** using the Firebase console's Rules Playground before deploying your app widely.

By following this structure and implementing robust security rules, your TeamEase application will have a solid foundation for managing team data securely and efficiently for multiple teams.
The application code in `src/services/` is designed to work with this Firestore structure.

