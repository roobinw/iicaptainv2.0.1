
# Firestore Database Setup and Structure for iiCaptain

This guide explains how to set up your Firestore database in the Firebase console and outlines the data structure that the iiCaptain application is designed to work with.

## 1. Creating Firestore Database in Firebase Console

If you haven't already, you need to create a Firestore database instance for your Firebase project:

1.  **Go to your Firebase Project:** Open the [Firebase Console](https://console.firebase.google.com/) and select your project.
2.  **Navigate to Firestore Database:** In the left-hand navigation pane, under "Build", click on "Firestore Database".
3.  **Create Database:**
    *   Click the "Create database" button.
    *   **Choose a mode:**
        *   **Production mode:** Starts with secure rules (denying all access by default). This is recommended. You will need to add security rules later (see section 4).
        *   **Test mode:** Starts with open rules (allowing all reads/writes for 30 days). Useful for initial development but **must be secured before production.**
    *   **Choose a location:** Select the region where your data will be stored. This cannot be changed later. Choose a location close to your users.
    *   Click "Enable".

Your Firestore database is now ready.

## 2. Firestore Data Structure

The application uses the following collection and subcollection structure to support multi-tenancy (each team has its own environment) and roles (admin, member).

### Collection: `teams`

This is a top-level collection where each document represents a unique team.

*   **Document ID:** Auto-generated by Firestore (this ID is referred to as `teamId` in the application).
*   **Fields:**
    *   `name`: (String) The name of the team (e.g., "The Eagles").
    *   `ownerUid`: (String) The Firebase Auth UID of the user who created/owns the team. This user is typically the first admin.
    *   `createdAt`: (Timestamp) Server timestamp indicating when the team was created.

*   **Subcollection of `teams/{teamId}`: `matches`**
    *   Stores all matches for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `date`: (String) Match date in "yyyy-MM-dd" format.
        *   `time`: (String) Match time in "HH:mm" format (24-hour).
        *   `opponent`: (String) Name of the opponent team.
        *   `location`: (String, optional) Venue of the match.
        *   `attendance`: (Map) Stores member attendance.
            *   Keys: Member Firebase Auth UIDs (String).
            *   Values: (String) "present", "absent", "excused", or "unknown".
            *   Example: `{"firebaseUserUid1": "present", "firebaseUserUid2": "absent"}`
        *   `isArchived`: (Boolean) `true` if the match is archived, `false` otherwise. Defaults to `false`.


*   **Subcollection of `teams/{teamId}`: `trainings`**
    *   Stores all training sessions for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `date`: (String) Training date in "yyyy-MM-dd" format.
        *   `time`: (String) Training time in "HH:mm" format (24-hour).
        *   `location`: (String) Location of the training session.
        *   `description`: (String, optional) Additional details about the training.
        *   `attendance`: (Map) Stores member attendance (same structure as in `matches`).
        *   `isArchived`: (Boolean) `true` if the training is archived, `false` otherwise. Defaults to `false`.

*   **Subcollection of `teams/{teamId}`: `refereeingAssignments`**
    *   Stores all refereeing assignments for a specific team.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `date`: (String) Assignment date in "yyyy-MM-dd" format.
        *   `time`: (String) Assignment time in "HH:mm" format (24-hour).
        *   `homeTeam`: (String, optional) The name of the home team for the match being refereed.
        *   `assignedPlayerUids`: (Array of Strings) Firebase Auth UIDs of the members assigned to referee.
        *   `notes`: (String, optional) Additional details or instructions for the assignment.
        *   `isArchived`: (Boolean) `true` if the assignment is archived, `false` otherwise. Defaults to `false`.

*   **Subcollection of `teams/{teamId}`: `messages`**
    *   Stores all team messages for the dashboard message board.
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `content`: (String) The content of the message.
        *   `authorUid`: (String) Firebase Auth UID of the admin who posted the message.
        *   `authorName`: (String) Name of the admin at the time of posting.
        *   `createdAt`: (Timestamp) Server timestamp indicating when the message was created.
        *   `teamId`: (String) The ID of the team this message belongs to (matches parent `teamId`).
        *   `isArchived`: (Boolean) `true` if the message is archived, `false` otherwise. Defaults to `false`.

*   **Subcollection of `teams/{teamId}`: `locations` (NEW)**
    *   Stores all custom locations for a specific team (e.g., training grounds, common away venues).
    *   **Document ID:** Auto-generated by Firestore.
    *   **Fields:**
        *   `name`: (String) The name of the location (e.g., "Main Training Field", "City Sports Complex Pitch 3").
        *   `address`: (String) The full address of the location.
        *   `createdAt`: (Timestamp) Server timestamp indicating when the location was added.
        *   `notes`: (String, optional) Additional notes about the location (e.g., parking info, specific entrance).

### Collection: `users`

This is a top-level collection where each document represents a user profile.

*   **Document ID:** This is **always** the Firebase Auth UID of the user.
*   **Fields:**
    *   `uid`: (String) The Firebase Auth UID. This field must match the document ID.
    *   `name`: (String) Full name of the user.
    *   `email`: (String) Email address of the user (stored in lowercase).
    *   `role`: (String) User's role within their team. Can be "admin" or "member".
    *   `teamId`: (String) The ID of the team (from the `teams` collection) that this user belongs to. This is crucial for multi-tenancy.
    *   `avatarUrl`: (String, optional) URL to the user's profile picture.
    *   `createdAt`: (Timestamp) Server timestamp indicating when the user profile was created.
    *   `isTrainingMember`: (Boolean) Defaults to `false`. `true` if the member participates in trainings.
    *   `isMatchMember`: (Boolean) Defaults to `false`. `true` if the member participates in matches.
    *   `isTeamManager`: (Boolean) Defaults to `false`. `true` if the member has team manager responsibilities.
    *   `isTrainer`: (Boolean) Defaults to `false`. `true` if the member is a trainer.
    *   `isCoach`: (Boolean) Defaults to `false`. `true` if the member is a coach.


### Collection: `tickets`

This is a top-level collection where each document represents a support ticket.

*   **Document ID:** Auto-generated by Firestore.
*   **Fields:**
    *   `userId`: (String) The Firebase Auth UID of the user who submitted the ticket.
    *   `userName`: (String) The name of the user at the time of submission.
    *   `userEmail`: (String) The email of the user at the time of submission.
    *   `teamId`: (String, optional) The `teamId` of the user, if they belong to one.
    *   `subject`: (String) The subject line of the support ticket.
    *   `message`: (String) The detailed message content of the support ticket.
    *   `status`: (String) The current status of the ticket (e.g., "open", "in-progress", "resolved", "closed"). Defaults to "open".
    *   `createdAt`: (Timestamp) Server timestamp indicating when the ticket was created.
    *   `updatedAt`: (Timestamp) Server timestamp, updated when the ticket status or content changes.


## 3. Example Document Structure

**Example `teams` document (`/teams/uniqueTeamId123`):**
```json
{
  "name": "The Roaring Lions",
  "ownerUid": "firebaseUserUidAbc",
  "createdAt": "October 26, 2023 at 10:00:00 AM UTC+2"
}
```

**Example `matches` subcollection document (`/teams/uniqueTeamId123/matches/matchId456`):**
```json
{
  "date": "2023-11-05",
  "time": "15:00",
  "opponent": "The Sharks",
  "location": "Community Stadium",
  "attendance": {
    "memberFirebaseUidXyz": "present",
    "memberFirebaseUidPqr": "excused"
  },
  "isArchived": false
}
```

**Example `trainings` subcollection document (`/teams/uniqueTeamId123/trainings/trainingId789`):**
```json
{
  "date": "2023-11-06",
  "time": "19:00",
  "location": "Main Training Field",
  "description": "Tactical drills and fitness.",
  "attendance": {
    "memberFirebaseUidXyz": "present"
  },
  "isArchived": false
}
```

**Example `refereeingAssignments` subcollection document (`/teams/uniqueTeamId123/refereeingAssignments/assignmentId789`):**
```json
{
  "date": "2023-11-12",
  "time": "10:00",
  "homeTeam": "The Bears",
  "assignedPlayerUids": ["memberFirebaseUidMno", "memberFirebaseUidJkl"],
  "notes": "Remember to bring whistles and cards. Arrive 30 mins early.",
  "isArchived": false
}
```

**Example `messages` subcollection document (`/teams/uniqueTeamId123/messages/messageIdAbc`):**
```json
{
  "content": "Important: Training is cancelled for this Friday due to bad weather.",
  "authorUid": "firebaseUserUidAbc",
  "authorName": "Jane Doe (Admin)",
  "createdAt": "November 15, 2023 at 09:30:00 AM UTC+1",
  "teamId": "uniqueTeamId123",
  "isArchived": false
}
```

**Example `locations` subcollection document (`/teams/uniqueTeamId123/locations/locationIdDef`):**
```json
{
  "name": "Community Sports Hall - Court 2",
  "address": "123 Main St, Anytown, USA",
  "createdAt": "November 20, 2023 at 11:00:00 AM UTC+1",
  "notes": "Parking available at the back. Use side entrance."
}
```

**Example `users` document (`/users/firebaseUserUidAbc` where `firebaseUserUidAbc` is the Firebase Auth UID):**
```json
{
  "uid": "firebaseUserUidAbc",
  "name": "Jane Doe",
  "email": "jane.doe@example.com",
  "role": "admin",
  "teamId": "uniqueTeamId123",
  "avatarUrl": "https://picsum.photos/seed/jane.doe@example.com/80/80",
  "createdAt": "October 26, 2023 at 09:55:00 AM UTC+2",
  "isTrainingMember": true,
  "isMatchMember": true,
  "isTeamManager": true,
  "isTrainer": false,
  "isCoach": false
}
```
**Example `users` document for a member added by an admin (`/users/newMemberAuthUid789`):**
```json
{
  "uid": "newMemberAuthUid789",
  "name": "John Member",
  "email": "john.member@example.com",
  "role": "member",
  "teamId": "uniqueTeamId123",
  "avatarUrl": "https://picsum.photos/seed/john.member@example.com/80/80",
  "createdAt": "October 27, 2023 at 11:00:00 AM UTC+2",
  "isTrainingMember": true,
  "isMatchMember": true,
  "isTeamManager": false,
  "isTrainer": false,
  "isCoach": false
}
```

**Example `tickets` document (`/tickets/ticketId789`):**
```json
{
  "userId": "firebaseUserUidAbc",
  "userName": "Jane Doe",
  "userEmail": "jane.doe@example.com",
  "teamId": "uniqueTeamId123",
  "subject": "Cannot update match details",
  "message": "I'm trying to update the location for our next match, but the save button is greyed out. Can you please help?",
  "status": "open",
  "createdAt": "November 10, 2023 at 02:30:00 PM UTC+1",
  "updatedAt": "November 10, 2023 at 02:30:00 PM UTC+1"
}
```

## 4. Initial Data and Security Rules

*   **Initial Data:**
    *   When a new user signs up via the app, they also provide a **Team Name** and their **own name**.
    *   The app then:
        1.  Creates their Firebase Authentication account.
        2.  Creates a new team document in the `teams` collection with the provided team name and sets the new user as `ownerUid`.
        3.  Creates their user profile document in the `users` collection (using their Firebase Auth UID as the document ID and the `uid` field), linking them to the newly created `teamId`, assigning them the `role: "admin"`, and setting default boolean roles (e.g., `isTrainingMember: true`, `isMatchMember: true`, `isTeamManager: true`, others `false`).
    *   Admins can then add other member profiles to their team via the "Members" page in the app. This:
        1. Creates a new Firebase Authentication account for the member using an email and password provided by the admin.
        2. Creates a `users` document for that member (using the new member's Firebase Auth UID as the document ID and the `uid` field), with `role: "member"`, the admin's `teamId`, and specified boolean roles (defaulting to `isTrainingMember: true`, `isMatchMember: true`, others `false` if not specified by form).
    *   Matches, Trainings, and Refereeing Assignments are added by team admins through the app into their respective team's subcollections. They default to `isArchived: false`.
    *   Messages are added by team admins via the dashboard message board. They default to `isArchived: false`.
    *   Locations are added by team admins via the app into their team's `locations` subcollection.
    *   Support tickets are created by any authenticated user via the "Support" page.

*   **Firestore Security Rules (VERY IMPORTANT):**
    *   Default security rules (especially in "Production mode") are highly restrictive. You **must** configure Firestore Security Rules.
    *   These rules enforce multi-tenancy (a user can only access data for their own team) and role-based access (only an admin can create/modify team-wide data like matches or other member profiles within their team).
    *   **Carefully copy and paste the rules below into the Firebase console Rules editor.**
    *   **If you encounter "Missing or insufficient permissions" errors, double-check that these rules are correctly applied and that your `users/{uid}` documents contain the correct `teamId` and `role` for the authenticated user.**

    **Security Rules:**
    ```firestore-rules
    rules_version = '2';

    service cloud.firestore {
      match /databases/{database}/documents {

        // Helper function to get requesting user's data (role, teamId)
        // Returns user data if document exists, otherwise null.
        function getUserAuthData() {
          // Construct the path string correctly using string concatenation for dynamic parts like request.auth.uid
          let userDocumentPath = path('/databases/' + database + '/documents/users/' + request.auth.uid);
          return exists(userDocumentPath) ? get(userDocumentPath).data : null;
        }

        // Helper: Is the user signed in?
        function isSignedIn() {
          return request.auth != null;
        }

        // Helper: Does the requesting user belong to the specified teamId?
        function isUserTeamMember(teamId) {
          let userAuthRecord = getUserAuthData();
          return isSignedIn() && userAuthRecord != null && userAuthRecord.teamId == teamId;
        }

        // Helper: Is the requesting user an admin of the specified teamId?
        function isUserTeamAdmin(teamId) {
          let userAuthData = getUserAuthData();
          return isUserTeamMember(teamId) && userAuthData != null && userAuthData.role == 'admin';
        }

        // Helper: Is the user creating/modifying their own document?
        // (used when document ID is the user's auth UID)
        function isOwner(userId) {
          return request.auth != null && request.auth.uid == userId;
        }

        // Teams collection
        match /teams/{teamId} {
          // Any authenticated user who is part of this team can read team details.
          allow read: if isUserTeamMember(teamId);
          // Only an authenticated user can create a team, and they must be its owner.
          allow create: if isSignedIn() && request.auth.uid == request.resource.data.ownerUid;
          // Only an admin of this team can update its name (ownerUid should not be changed by client).
          allow update: if isUserTeamAdmin(teamId) && request.resource.data.ownerUid == resource.data.ownerUid;
          // Deleting teams is typically a backend/admin function, not client-side.
          allow delete: if false;
        }

        // Users collection
        match /users/{userId} {
          // Any signed-in user can read any user profile (e.g., to see names for attendance or their own profile).
          allow read: if isSignedIn();

          // Allow creation of user documents under two conditions:
          // 1. A user creating their own profile (documentId {userId} == auth.uid).
          // 2. An admin creating a member profile (and associated auth account) for their team.
          //    The documentId {userId} will be the new member's Firebase Auth UID.
          allow create: if isSignedIn() &&
                          (
                            // Case 1: User creating their own profile (e.g., during signup)
                            ( isOwner(userId) &&
                              request.resource.data.uid == request.auth.uid &&
                              request.resource.data.email != null &&
                              request.resource.data.name != null &&
                              request.resource.data.role != null &&
                              request.resource.data.teamId != null &&
                              // Check boolean roles are booleans if present, or not present
                              (request.resource.data.isTrainingMember is bool || !('isTrainingMember' in request.resource.data)) &&
                              (request.resource.data.isMatchMember is bool || !('isMatchMember' in request.resource.data)) &&
                              (request.resource.data.isTeamManager is bool || !('isTeamManager' in request.resource.data)) &&
                              (request.resource.data.isTrainer is bool || !('isTrainer' in request.resource.data)) &&
                              (request.resource.data.isCoach is bool || !('isCoach' in request.resource.data))
                            ) ||
                            // Case 2: Admin creating a member profile for their team
                            ( getUserAuthData() != null &&
                              getUserAuthData().role == 'admin' &&
                              request.resource.data.teamId == getUserAuthData().teamId &&
                              request.resource.data.uid == userId &&
                              request.resource.data.email != null &&
                              request.resource.data.name != null &&
                              request.resource.data.role == 'member' &&
                              (request.resource.data.isTrainingMember is bool || !('isTrainingMember' in request.resource.data)) &&
                              (request.resource.data.isMatchMember is bool || !('isMatchMember' in request.resource.data)) &&
                              (request.resource.data.isTeamManager is bool || !('isTeamManager' in request.resource.data)) &&
                              (request.resource.data.isTrainer is bool || !('isTrainer' in request.resource.data)) &&
                              (request.resource.data.isCoach is bool || !('isCoach' in request.resource.data))
                            )
                          );

          // A user can update their own profile (e.g., name, avatarUrl, their boolean roles).
          // An admin can update profiles of users within their own team (name, role, avatarUrl, boolean roles).
          allow update: if isSignedIn() &&
                          (
                            // Case 1: User is updating their own profile
                            (isOwner(userId) &&
                              // Ensure immutable fields are not being changed if they are part of the request.
                              // Client doesn't typically send these for updates, but this is for safety.
                              (request.resource.data.uid == resource.data.uid || !('uid' in request.resource.data)) &&
                              (request.resource.data.email == resource.data.email || !('email' in request.resource.data)) &&
                              (request.resource.data.role == resource.data.role || !('role' in request.resource.data)) && // User cannot change their own role
                              (request.resource.data.teamId == resource.data.teamId || !('teamId' in request.resource.data)) && // User cannot change their own teamId
                              (request.resource.data.createdAt == resource.data.createdAt || !('createdAt' in request.resource.data)) &&
                              // Allow updates to 'name', 'avatarUrl', and boolean roles.
                              // Validate types of boolean fields if they are present.
                              (request.resource.data.isTrainingMember is bool || !('isTrainingMember' in request.resource.data)) &&
                              (request.resource.data.isMatchMember is bool || !('isMatchMember' in request.resource.data)) &&
                              (request.resource.data.isTeamManager is bool || !('isTeamManager' in request.resource.data)) &&
                              (request.resource.data.isTrainer is bool || !('isTrainer' in request.resource.data)) &&
                              (request.resource.data.isCoach is bool || !('isCoach' in request.resource.data))
                              // Allowed to change: name, avatarUrl, boolean flags.
                              // Check that no other fields are being changed besides the allowed ones.
                              // This means the update payload can only contain name, avatarUrl, and the boolean flags.
                              // All other fields in request.resource.data must not be present OR must match existing.
                              // This also ensures that if a user *only* sends boolean flags, it's okay.
                            ) ||
                            // Case 2: Admin is updating another user's profile within their team
                            (
                              isUserTeamAdmin(resource.data.teamId) && // Requester is admin of the user's team
                              resource.data.teamId == getUserAuthData().teamId && // Admin is in the same team as the user being updated
                              userId != request.auth.uid && // Admin cannot use this to update their own profile with admin privileges
                              // Ensure immutable fields are not being changed if they are part of the request.
                              (request.resource.data.uid == resource.data.uid || !('uid' in request.resource.data)) &&
                              (request.resource.data.teamId == resource.data.teamId || !('teamId' in request.resource.data)) && // Admin cannot change user's teamId
                              (request.resource.data.email == resource.data.email || !('email' in request.resource.data)) && // Admin cannot change user's email
                              (request.resource.data.createdAt == resource.data.createdAt || !('createdAt'in request.resource.data)) &&
                              // Allow updates to 'name', 'role', 'avatarUrl', and boolean roles.
                              // Validate types of boolean fields if they are present.
                              (request.resource.data.isTrainingMember is bool || !('isTrainingMember' in request.resource.data)) &&
                              (request.resource.data.isMatchMember is bool || !('isMatchMember' in request.resource.data)) &&
                              (request.resource.data.isTeamManager is bool || !('isTeamManager' in request.resource.data)) &&
                              (request.resource.data.isTrainer is bool || !('isTrainer' in request.resource.data)) &&
                              (request.resource.data.isCoach is bool || !('isCoach' in request.resource.data)) &&
                              // Validate 'role' if present (admin can change member to admin, or admin to member - except owner of team)
                              (request.resource.data.role is string || !('role' in request.resource.data)) &&
                              ( (resource.data.ownerUid == userId && request.resource.data.role == 'admin') || resource.data.ownerUid != userId ) // Owner must remain admin
                            )
                          );

          // An admin can delete user profiles from their team (except their own).
          allow delete: if isUserTeamAdmin(resource.data.teamId) &&
                          resource.data.teamId == getUserAuthData().teamId &&
                          userId != request.auth.uid;
        }

        // Matches subcollection (nested under a specific team)
        match /teams/{teamId}/matches/{matchId} {
          allow read: if isUserTeamMember(teamId);
          allow create: if isUserTeamAdmin(teamId) && request.resource.data.isArchived == false;
          allow update: if isUserTeamAdmin(teamId) &&
                           (
                             request.resource.data.isArchived != resource.data.isArchived &&
                             request.resource.data.date == resource.data.date &&
                             request.resource.data.time == resource.data.time &&
                             request.resource.data.opponent == resource.data.opponent &&
                             request.resource.data.location == resource.data.location &&
                             request.resource.data.attendance == resource.data.attendance
                           ) ||
                           (
                             request.resource.data.isArchived == resource.data.isArchived || request.resource.data.isArchived != resource.data.isArchived
                           );
          allow delete: if isUserTeamAdmin(teamId);
        }

        // Trainings subcollection (nested under a specific team)
        match /teams/{teamId}/trainings/{trainingId} {
          allow read: if isUserTeamMember(teamId);
          allow create: if isUserTeamAdmin(teamId) && request.resource.data.isArchived == false;
          allow update: if isUserTeamAdmin(teamId) &&
                           (
                             request.resource.data.isArchived != resource.data.isArchived &&
                             request.resource.data.date == resource.data.date &&
                             request.resource.data.time == resource.data.time &&
                             request.resource.data.location == resource.data.location &&
                             request.resource.data.description == resource.data.description &&
                             request.resource.data.attendance == resource.data.attendance
                           ) ||
                           (
                             request.resource.data.isArchived == resource.data.isArchived || request.resource.data.isArchived != resource.data.isArchived
                           );
          allow delete: if isUserTeamAdmin(teamId);
        }

        // Refereeing Assignments subcollection (nested under a specific team)
        match /teams/{teamId}/refereeingAssignments/{assignmentId} {
          allow read: if isUserTeamMember(teamId);
          allow create: if isUserTeamAdmin(teamId) && request.resource.data.isArchived == false;
          allow update: if isUserTeamAdmin(teamId) &&
                           (
                             request.resource.data.isArchived != resource.data.isArchived &&
                             request.resource.data.date == resource.data.date &&
                             request.resource.data.time == resource.data.time &&
                             request.resource.data.homeTeam == resource.data.homeTeam &&
                             request.resource.data.assignedPlayerUids == resource.data.assignedPlayerUids &&
                             request.resource.data.notes == resource.data.notes
                           ) ||
                           (
                             request.resource.data.isArchived == resource.data.isArchived || request.resource.data.isArchived != resource.data.isArchived
                           );
          allow delete: if isUserTeamAdmin(teamId);
        }

        // Messages subcollection (nested under a specific team)
        match /teams/{teamId}/messages/{messageId} {
          allow read: if isUserTeamMember(teamId);
          allow create: if isUserTeamAdmin(teamId) &&
                           request.resource.data.authorUid == request.auth.uid &&
                           request.resource.data.teamId == teamId &&
                           request.resource.data.content != null &&
                           request.resource.data.authorName != null &&
                           request.resource.data.isArchived == false;

          allow update: if isUserTeamAdmin(teamId) &&
                           request.resource.data.authorUid == resource.data.authorUid &&
                           request.resource.data.teamId == resource.data.teamId &&
                           request.resource.data.content == resource.data.content &&
                           request.resource.data.authorName == resource.data.authorName &&
                           request.resource.data.createdAt.toMillis() == resource.data.createdAt.toMillis();

          allow delete: if isUserTeamAdmin(teamId);
        }

        // Locations subcollection
        match /teams/{teamId}/locations/{locationId} {
          allow read: if isUserTeamMember(teamId);
          allow create: if isUserTeamAdmin(teamId);
          allow update: if isUserTeamAdmin(teamId);
          allow delete: if isUserTeamAdmin(teamId);
        }

        // Tickets collection
        match /tickets/{ticketId} {
          allow create: if isSignedIn() &&
                          request.resource.data.userId == request.auth.uid &&
                          request.resource.data.status == 'open' &&
                          request.resource.data.subject != null &&
                          request.resource.data.message != null &&
                          request.resource.data.userName != null &&
                          request.resource.data.userEmail != null;

          allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
          allow update: if isSignedIn() && resource.data.userId == request.auth.uid &&
                          request.resource.data.userId == resource.data.userId &&
                          request.resource.data.teamId == resource.data.teamId &&
                          request.resource.data.userName == resource.data.userName &&
                          request.resource.data.userEmail == resource.data.userEmail &&
                          request.resource.data.createdAt.toMillis() == resource.data.createdAt.toMillis();
          allow delete: if false;
        }
      }
    }
    ```
    *   **Test your security rules thoroughly** using the Firebase console's Rules Playground.

## 5. Required Firestore Indexes

*   **Collection Group:** `matches`
    *   **Fields:** 1. `date` (Ascending), 2. `time` (Ascending)
    *   **Query scope:** Collection group

*   **Collection Group:** `matches` (For filtering archived matches)
    *   **Fields:** 1. `isArchived` (Ascending), 2. `date` (Ascending), 3. `time` (Ascending)
    *   **Query scope:** Collection group

*   **Collection Group:** `trainings`
    *   **Fields:** 1. `date` (Ascending), 2. `time` (Ascending)
    *   **Query scope:** Collection group

*   **Collection Group:** `trainings` (For filtering archived trainings)
    *   **Fields:** 1. `isArchived` (Ascending), 2. `date` (Ascending), 3. `time` (Ascending)
    *   **Query scope:** Collection group

*   **Collection Group:** `refereeingAssignments`
    *   **Fields:** 1. `date` (Ascending), 2. `time` (Ascending)
    *   **Query scope:** Collection group

*   **Collection Group:** `refereeingAssignments` (For filtering archived assignments)
    *   **Fields:** 1. `isArchived` (Ascending), 2. `date` (Ascending), 3. `time` (Ascending)
    *   **Query scope:** Collection group

*   **Collection Group:** `messages`
    *   **Fields:** 1. `createdAt` (Descending)
    *   **Query scope:** Collection group

*   **Collection Group:** `messages` (For filtering archived messages)
    *   **Fields:** 1. `isArchived` (Ascending), 2. `createdAt` (Descending)
    *   **Query scope:** Collection group

*   **Collection Group:** `locations` (For sorting locations by name)
    *   **Fields:** 1. `name` (Ascending)
    *   **Query scope:** Collection group

*   **Collection:** `users`
    *   **Fields:** 1. `teamId` (Ascending), 2. `name` (Ascending)
    *   **Query scope:** Collection

*   **Collection:** `users`
    *   **Fields:** 1. `teamId` (Ascending), 2. `role` (Ascending), 3. `name` (Ascending)
    *   **Query scope:** Collection

*   **Collection:** `tickets`
    *   **Fields:** 1. `userId` (Ascending), 2. `createdAt` (Descending)
    *   **Query scope:** Collection

By following this structure, implementing robust security rules, and creating the necessary indexes, your iiCaptain application will have a solid foundation for managing team data securely and efficiently.

    